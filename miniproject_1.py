# -*- coding: utf-8 -*-
"""MiniProject #1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YfPO8jo9H5RdTilyvzEmw_cQ1Sj4r1Kr

Part 1 – NumPy, Matplotlib/Seaborn:

Q1 (35pts): Convert covariance matrix into correlation matrix using numpy.
for this question i used the website geeksforgeeks:
https://www.geeksforgeeks.org/convert-covariance-matrix-to-correlation-matrix-using-python/


A. Briefly explain in 1-2 sentences the concepts of Covariance and Correlation, and describe their relationship. You may use equations for clarification

Answer: The two terms represent a dependence between two variables. Covariance tells us the connection between two variables, specifically how they change together, while correlation tells us the strength and direction of this relationship in a normalized scale, ranging from 1 to −1 . Correlation also standardizes the relationship, making it easier to compare across different datasets or variables regardless of their units.

B. Load the Iris dataset, using any method of your choice (e.g.: pd.read_csv("iris.csv") in Pandas).
Use visualization to explore the relationship between the different features.
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px


iris_df = sns.load_dataset("iris")
iris_df.head()
iris_df.info()

sns.pairplot(iris_df, hue='species', palette='tab10')

# Correlation between Petal lenght to the sepal length
fig = px.scatter(iris_df, x='sepal_length',
                y='petal_length',
                color='species',
                title='Correltion between petal length and sepal length')
fig.update_traces(marker={'size': 15})

fig.show()

#Distribution of Iris petal length for every species
fig = px.box(iris_df, x="species", y="petal_length")
fig.update_layout(title="Distribution of Iris petal length for every species",
                xaxis_title="Species",
                yaxis_title="petal length",
                width=600,
                height=400)
fig.show()

#hisplot showing the Rough estimate size of the flower (length x width of petal) to each species
iris_df['flower_size'] = iris_df['petal_length'] * iris_df['petal_width']
avg_flower_size = iris_df.groupby('species')['flower_size'].mean()
plt.bar(['setosa', 'versicolor','virginica'], avg_flower_size, color=['red', 'blue', 'orange'])
plt.title('Average flower size')
plt.xlabel('spesies')
plt.ylabel('petal length X petal width')
plt.show()

"""C. Implement the following functions:

a. A function to calculate the covariance between two variables:
def calcCov(x, y): <your implementation here>,

b. A function to compute the Covariance matrix:
def covMat(data): <your implementation here>

covMat(data) should return an n by n covariance matrix, where n is the
number of features (in case of the iris dataset n=4)
"""

#C.a.
def calcCov(x, y): #corr()
    mean_x = x.mean()
    mean_y = y.mean()
    cov = ((x - mean_x) * (y - mean_y)).sum()/(x.shape[0]-1)
    return cov
#C.b.
def covMat(data):
    numeric_data = data.select_dtypes(include=np.number)
    n = numeric_data.shape[1]
    cov_matrix = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            cov_matrix[i, j] = calcCov(numeric_data.iloc[:, i], numeric_data.iloc[:, j])
    return cov_matrix

"""D. Test1: compare the results of your function with NumPy's
np.cov(data,rowvar=False) using the iris dataset.
"""

numeric_data = iris_df.select_dtypes(include=np.number)
np.cov(numeric_data,rowvar=False)

"""E. Using your covariance function, implement a function to calculate the correlation
matrix:
def corrMat(data):<should use covMat(data) and return the correlation matrix>
"""

def corrMat(data):
  #corr(x,y)=  Covariance / stdx *stdy
      cov_matrix = covMat(data) #using my function
      n = cov_matrix.shape[1]
      corr_matrix = np.zeros((n, n))
      std_dev = np.sqrt(np.diag(cov_matrix)) ## caculting the std by sqrt of variances
      for i in range(n):
        for j in range(n):
            corr_matrix[i, j] = cov_matrix[i, j] / (std_dev[i] * std_dev[j])
      return corr_matrix

print(corrMat(iris_df))

"""F. Test2: validate your correlation matrix implementation by comparing it with the
results of NumPy's np.corrcoef(data,rowvar=False), using the iris dataset.
"""

numeric_data = iris_df.select_dtypes(include=np.number)
np.corrcoef(numeric_data,rowvar=False)

"""G. Use visualizations to communicate the tests results. Include appropriate titles,
axis labels, and colorbars where relevant.
"""

correlation_matrix = corrMat(iris_df)
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap="coolwarm", fmt=".2f", xticklabels=['sepal_length', 'sepal_width', 'petal_length', 'petal_width'], yticklabels=['sepal_length', 'sepal_width', 'petal_length', 'petal_width'])
plt.title("Correlation Matrix- with my function")
plt.show()